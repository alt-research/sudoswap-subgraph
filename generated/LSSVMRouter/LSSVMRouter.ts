// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  ethereum,
  JSONValue,
  TypedMap,
  Entity,
  Bytes,
  Address,
  BigInt
} from "@graphprotocol/graph-ts";

export class LSSVMRouter__robustSwapERC20ForAnyNFTsInputSwapListStruct extends ethereum.Tuple {
  get swapInfo(): LSSVMRouter__robustSwapERC20ForAnyNFTsInputSwapListSwapInfoStruct {
    return changetype<
      LSSVMRouter__robustSwapERC20ForAnyNFTsInputSwapListSwapInfoStruct
    >(this[0].toTuple());
  }

  get maxCost(): BigInt {
    return this[1].toBigInt();
  }
}

export class LSSVMRouter__robustSwapERC20ForAnyNFTsInputSwapListSwapInfoStruct extends ethereum.Tuple {
  get pair(): Address {
    return this[0].toAddress();
  }

  get numItems(): BigInt {
    return this[1].toBigInt();
  }
}

export class LSSVMRouter__robustSwapNFTsForTokenInputSwapListStruct extends ethereum.Tuple {
  get swapInfo(): LSSVMRouter__robustSwapNFTsForTokenInputSwapListSwapInfoStruct {
    return changetype<
      LSSVMRouter__robustSwapNFTsForTokenInputSwapListSwapInfoStruct
    >(this[0].toTuple());
  }

  get minOutput(): BigInt {
    return this[1].toBigInt();
  }
}

export class LSSVMRouter__robustSwapNFTsForTokenInputSwapListSwapInfoStruct extends ethereum.Tuple {
  get pair(): Address {
    return this[0].toAddress();
  }

  get nftIds(): Array<BigInt> {
    return this[1].toBigIntArray();
  }
}

export class LSSVMRouter__swapERC20ForAnyNFTsInputSwapListStruct extends ethereum.Tuple {
  get pair(): Address {
    return this[0].toAddress();
  }

  get numItems(): BigInt {
    return this[1].toBigInt();
  }
}

export class LSSVMRouter__swapERC20ForSpecificNFTsInputSwapListStruct extends ethereum.Tuple {
  get pair(): Address {
    return this[0].toAddress();
  }

  get nftIds(): Array<BigInt> {
    return this[1].toBigIntArray();
  }
}

export class LSSVMRouter__swapNFTsForAnyNFTsThroughERC20InputTradeStruct extends ethereum.Tuple {
  get nftToTokenTrades(): Array<
    LSSVMRouter__swapNFTsForAnyNFTsThroughERC20InputTradeNftToTokenTradesStruct
  > {
    return this[0].toTupleArray<
      LSSVMRouter__swapNFTsForAnyNFTsThroughERC20InputTradeNftToTokenTradesStruct
    >();
  }

  get tokenToNFTTrades(): Array<
    LSSVMRouter__swapNFTsForAnyNFTsThroughERC20InputTradeTokenToNFTTradesStruct
  > {
    return this[1].toTupleArray<
      LSSVMRouter__swapNFTsForAnyNFTsThroughERC20InputTradeTokenToNFTTradesStruct
    >();
  }
}

export class LSSVMRouter__swapNFTsForAnyNFTsThroughERC20InputTradeNftToTokenTradesStruct extends ethereum.Tuple {
  get pair(): Address {
    return this[0].toAddress();
  }

  get nftIds(): Array<BigInt> {
    return this[1].toBigIntArray();
  }
}

export class LSSVMRouter__swapNFTsForAnyNFTsThroughERC20InputTradeTokenToNFTTradesStruct extends ethereum.Tuple {
  get pair(): Address {
    return this[0].toAddress();
  }

  get numItems(): BigInt {
    return this[1].toBigInt();
  }
}

export class LSSVMRouter__swapNFTsForSpecificNFTsThroughERC20InputTradeStruct extends ethereum.Tuple {
  get nftToTokenTrades(): Array<
    LSSVMRouter__swapNFTsForSpecificNFTsThroughERC20InputTradeNftToTokenTradesStruct
  > {
    return this[0].toTupleArray<
      LSSVMRouter__swapNFTsForSpecificNFTsThroughERC20InputTradeNftToTokenTradesStruct
    >();
  }

  get tokenToNFTTrades(): Array<
    LSSVMRouter__swapNFTsForSpecificNFTsThroughERC20InputTradeTokenToNFTTradesStruct
  > {
    return this[1].toTupleArray<
      LSSVMRouter__swapNFTsForSpecificNFTsThroughERC20InputTradeTokenToNFTTradesStruct
    >();
  }
}

export class LSSVMRouter__swapNFTsForSpecificNFTsThroughERC20InputTradeNftToTokenTradesStruct extends ethereum.Tuple {
  get pair(): Address {
    return this[0].toAddress();
  }

  get nftIds(): Array<BigInt> {
    return this[1].toBigIntArray();
  }
}

export class LSSVMRouter__swapNFTsForSpecificNFTsThroughERC20InputTradeTokenToNFTTradesStruct extends ethereum.Tuple {
  get pair(): Address {
    return this[0].toAddress();
  }

  get nftIds(): Array<BigInt> {
    return this[1].toBigIntArray();
  }
}

export class LSSVMRouter__swapNFTsForTokenInputSwapListStruct extends ethereum.Tuple {
  get pair(): Address {
    return this[0].toAddress();
  }

  get nftIds(): Array<BigInt> {
    return this[1].toBigIntArray();
  }
}

export class LSSVMRouter extends ethereum.SmartContract {
  static bind(address: Address): LSSVMRouter {
    return new LSSVMRouter("LSSVMRouter", address);
  }

  factory(): Address {
    let result = super.call("factory", "factory():(address)", []);

    return result[0].toAddress();
  }

  try_factory(): ethereum.CallResult<Address> {
    let result = super.tryCall("factory", "factory():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  robustSwapERC20ForAnyNFTs(
    swapList: Array<LSSVMRouter__robustSwapERC20ForAnyNFTsInputSwapListStruct>,
    inputAmount: BigInt,
    nftRecipient: Address,
    deadline: BigInt
  ): BigInt {
    let result = super.call(
      "robustSwapERC20ForAnyNFTs",
      "robustSwapERC20ForAnyNFTs(((address,uint256),uint256)[],uint256,address,uint256):(uint256)",
      [
        ethereum.Value.fromTupleArray(swapList),
        ethereum.Value.fromUnsignedBigInt(inputAmount),
        ethereum.Value.fromAddress(nftRecipient),
        ethereum.Value.fromUnsignedBigInt(deadline)
      ]
    );

    return result[0].toBigInt();
  }

  try_robustSwapERC20ForAnyNFTs(
    swapList: Array<LSSVMRouter__robustSwapERC20ForAnyNFTsInputSwapListStruct>,
    inputAmount: BigInt,
    nftRecipient: Address,
    deadline: BigInt
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "robustSwapERC20ForAnyNFTs",
      "robustSwapERC20ForAnyNFTs(((address,uint256),uint256)[],uint256,address,uint256):(uint256)",
      [
        ethereum.Value.fromTupleArray(swapList),
        ethereum.Value.fromUnsignedBigInt(inputAmount),
        ethereum.Value.fromAddress(nftRecipient),
        ethereum.Value.fromUnsignedBigInt(deadline)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  robustSwapNFTsForToken(
    swapList: Array<LSSVMRouter__robustSwapNFTsForTokenInputSwapListStruct>,
    tokenRecipient: Address,
    deadline: BigInt
  ): BigInt {
    let result = super.call(
      "robustSwapNFTsForToken",
      "robustSwapNFTsForToken(((address,uint256[]),uint256)[],address,uint256):(uint256)",
      [
        ethereum.Value.fromTupleArray(swapList),
        ethereum.Value.fromAddress(tokenRecipient),
        ethereum.Value.fromUnsignedBigInt(deadline)
      ]
    );

    return result[0].toBigInt();
  }

  try_robustSwapNFTsForToken(
    swapList: Array<LSSVMRouter__robustSwapNFTsForTokenInputSwapListStruct>,
    tokenRecipient: Address,
    deadline: BigInt
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "robustSwapNFTsForToken",
      "robustSwapNFTsForToken(((address,uint256[]),uint256)[],address,uint256):(uint256)",
      [
        ethereum.Value.fromTupleArray(swapList),
        ethereum.Value.fromAddress(tokenRecipient),
        ethereum.Value.fromUnsignedBigInt(deadline)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  swapERC20ForAnyNFTs(
    swapList: Array<LSSVMRouter__swapERC20ForAnyNFTsInputSwapListStruct>,
    inputAmount: BigInt,
    nftRecipient: Address,
    deadline: BigInt
  ): BigInt {
    let result = super.call(
      "swapERC20ForAnyNFTs",
      "swapERC20ForAnyNFTs((address,uint256)[],uint256,address,uint256):(uint256)",
      [
        ethereum.Value.fromTupleArray(swapList),
        ethereum.Value.fromUnsignedBigInt(inputAmount),
        ethereum.Value.fromAddress(nftRecipient),
        ethereum.Value.fromUnsignedBigInt(deadline)
      ]
    );

    return result[0].toBigInt();
  }

  try_swapERC20ForAnyNFTs(
    swapList: Array<LSSVMRouter__swapERC20ForAnyNFTsInputSwapListStruct>,
    inputAmount: BigInt,
    nftRecipient: Address,
    deadline: BigInt
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "swapERC20ForAnyNFTs",
      "swapERC20ForAnyNFTs((address,uint256)[],uint256,address,uint256):(uint256)",
      [
        ethereum.Value.fromTupleArray(swapList),
        ethereum.Value.fromUnsignedBigInt(inputAmount),
        ethereum.Value.fromAddress(nftRecipient),
        ethereum.Value.fromUnsignedBigInt(deadline)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  swapERC20ForSpecificNFTs(
    swapList: Array<LSSVMRouter__swapERC20ForSpecificNFTsInputSwapListStruct>,
    inputAmount: BigInt,
    nftRecipient: Address,
    deadline: BigInt
  ): BigInt {
    let result = super.call(
      "swapERC20ForSpecificNFTs",
      "swapERC20ForSpecificNFTs((address,uint256[])[],uint256,address,uint256):(uint256)",
      [
        ethereum.Value.fromTupleArray(swapList),
        ethereum.Value.fromUnsignedBigInt(inputAmount),
        ethereum.Value.fromAddress(nftRecipient),
        ethereum.Value.fromUnsignedBigInt(deadline)
      ]
    );

    return result[0].toBigInt();
  }

  try_swapERC20ForSpecificNFTs(
    swapList: Array<LSSVMRouter__swapERC20ForSpecificNFTsInputSwapListStruct>,
    inputAmount: BigInt,
    nftRecipient: Address,
    deadline: BigInt
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "swapERC20ForSpecificNFTs",
      "swapERC20ForSpecificNFTs((address,uint256[])[],uint256,address,uint256):(uint256)",
      [
        ethereum.Value.fromTupleArray(swapList),
        ethereum.Value.fromUnsignedBigInt(inputAmount),
        ethereum.Value.fromAddress(nftRecipient),
        ethereum.Value.fromUnsignedBigInt(deadline)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  swapNFTsForAnyNFTsThroughERC20(
    trade: LSSVMRouter__swapNFTsForAnyNFTsThroughERC20InputTradeStruct,
    inputAmount: BigInt,
    minOutput: BigInt,
    nftRecipient: Address,
    deadline: BigInt
  ): BigInt {
    let result = super.call(
      "swapNFTsForAnyNFTsThroughERC20",
      "swapNFTsForAnyNFTsThroughERC20(((address,uint256[])[],(address,uint256)[]),uint256,uint256,address,uint256):(uint256)",
      [
        ethereum.Value.fromTuple(trade),
        ethereum.Value.fromUnsignedBigInt(inputAmount),
        ethereum.Value.fromUnsignedBigInt(minOutput),
        ethereum.Value.fromAddress(nftRecipient),
        ethereum.Value.fromUnsignedBigInt(deadline)
      ]
    );

    return result[0].toBigInt();
  }

  try_swapNFTsForAnyNFTsThroughERC20(
    trade: LSSVMRouter__swapNFTsForAnyNFTsThroughERC20InputTradeStruct,
    inputAmount: BigInt,
    minOutput: BigInt,
    nftRecipient: Address,
    deadline: BigInt
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "swapNFTsForAnyNFTsThroughERC20",
      "swapNFTsForAnyNFTsThroughERC20(((address,uint256[])[],(address,uint256)[]),uint256,uint256,address,uint256):(uint256)",
      [
        ethereum.Value.fromTuple(trade),
        ethereum.Value.fromUnsignedBigInt(inputAmount),
        ethereum.Value.fromUnsignedBigInt(minOutput),
        ethereum.Value.fromAddress(nftRecipient),
        ethereum.Value.fromUnsignedBigInt(deadline)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  swapNFTsForSpecificNFTsThroughERC20(
    trade: LSSVMRouter__swapNFTsForSpecificNFTsThroughERC20InputTradeStruct,
    inputAmount: BigInt,
    minOutput: BigInt,
    nftRecipient: Address,
    deadline: BigInt
  ): BigInt {
    let result = super.call(
      "swapNFTsForSpecificNFTsThroughERC20",
      "swapNFTsForSpecificNFTsThroughERC20(((address,uint256[])[],(address,uint256[])[]),uint256,uint256,address,uint256):(uint256)",
      [
        ethereum.Value.fromTuple(trade),
        ethereum.Value.fromUnsignedBigInt(inputAmount),
        ethereum.Value.fromUnsignedBigInt(minOutput),
        ethereum.Value.fromAddress(nftRecipient),
        ethereum.Value.fromUnsignedBigInt(deadline)
      ]
    );

    return result[0].toBigInt();
  }

  try_swapNFTsForSpecificNFTsThroughERC20(
    trade: LSSVMRouter__swapNFTsForSpecificNFTsThroughERC20InputTradeStruct,
    inputAmount: BigInt,
    minOutput: BigInt,
    nftRecipient: Address,
    deadline: BigInt
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "swapNFTsForSpecificNFTsThroughERC20",
      "swapNFTsForSpecificNFTsThroughERC20(((address,uint256[])[],(address,uint256[])[]),uint256,uint256,address,uint256):(uint256)",
      [
        ethereum.Value.fromTuple(trade),
        ethereum.Value.fromUnsignedBigInt(inputAmount),
        ethereum.Value.fromUnsignedBigInt(minOutput),
        ethereum.Value.fromAddress(nftRecipient),
        ethereum.Value.fromUnsignedBigInt(deadline)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  swapNFTsForToken(
    swapList: Array<LSSVMRouter__swapNFTsForTokenInputSwapListStruct>,
    minOutput: BigInt,
    tokenRecipient: Address,
    deadline: BigInt
  ): BigInt {
    let result = super.call(
      "swapNFTsForToken",
      "swapNFTsForToken((address,uint256[])[],uint256,address,uint256):(uint256)",
      [
        ethereum.Value.fromTupleArray(swapList),
        ethereum.Value.fromUnsignedBigInt(minOutput),
        ethereum.Value.fromAddress(tokenRecipient),
        ethereum.Value.fromUnsignedBigInt(deadline)
      ]
    );

    return result[0].toBigInt();
  }

  try_swapNFTsForToken(
    swapList: Array<LSSVMRouter__swapNFTsForTokenInputSwapListStruct>,
    minOutput: BigInt,
    tokenRecipient: Address,
    deadline: BigInt
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "swapNFTsForToken",
      "swapNFTsForToken((address,uint256[])[],uint256,address,uint256):(uint256)",
      [
        ethereum.Value.fromTupleArray(swapList),
        ethereum.Value.fromUnsignedBigInt(minOutput),
        ethereum.Value.fromAddress(tokenRecipient),
        ethereum.Value.fromUnsignedBigInt(deadline)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }
}

export class ConstructorCall extends ethereum.Call {
  get inputs(): ConstructorCall__Inputs {
    return new ConstructorCall__Inputs(this);
  }

  get outputs(): ConstructorCall__Outputs {
    return new ConstructorCall__Outputs(this);
  }
}

export class ConstructorCall__Inputs {
  _call: ConstructorCall;

  constructor(call: ConstructorCall) {
    this._call = call;
  }

  get _factory(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class ConstructorCall__Outputs {
  _call: ConstructorCall;

  constructor(call: ConstructorCall) {
    this._call = call;
  }
}

export class PairTransferERC20FromCall extends ethereum.Call {
  get inputs(): PairTransferERC20FromCall__Inputs {
    return new PairTransferERC20FromCall__Inputs(this);
  }

  get outputs(): PairTransferERC20FromCall__Outputs {
    return new PairTransferERC20FromCall__Outputs(this);
  }
}

export class PairTransferERC20FromCall__Inputs {
  _call: PairTransferERC20FromCall;

  constructor(call: PairTransferERC20FromCall) {
    this._call = call;
  }

  get token(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get from(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get to(): Address {
    return this._call.inputValues[2].value.toAddress();
  }

  get amount(): BigInt {
    return this._call.inputValues[3].value.toBigInt();
  }

  get variant(): i32 {
    return this._call.inputValues[4].value.toI32();
  }
}

export class PairTransferERC20FromCall__Outputs {
  _call: PairTransferERC20FromCall;

  constructor(call: PairTransferERC20FromCall) {
    this._call = call;
  }
}

export class PairTransferNFTFromCall extends ethereum.Call {
  get inputs(): PairTransferNFTFromCall__Inputs {
    return new PairTransferNFTFromCall__Inputs(this);
  }

  get outputs(): PairTransferNFTFromCall__Outputs {
    return new PairTransferNFTFromCall__Outputs(this);
  }
}

export class PairTransferNFTFromCall__Inputs {
  _call: PairTransferNFTFromCall;

  constructor(call: PairTransferNFTFromCall) {
    this._call = call;
  }

  get nft(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get from(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get to(): Address {
    return this._call.inputValues[2].value.toAddress();
  }

  get id(): BigInt {
    return this._call.inputValues[3].value.toBigInt();
  }

  get variant(): i32 {
    return this._call.inputValues[4].value.toI32();
  }
}

export class PairTransferNFTFromCall__Outputs {
  _call: PairTransferNFTFromCall;

  constructor(call: PairTransferNFTFromCall) {
    this._call = call;
  }
}

export class RobustSwapERC20ForAnyNFTsCall extends ethereum.Call {
  get inputs(): RobustSwapERC20ForAnyNFTsCall__Inputs {
    return new RobustSwapERC20ForAnyNFTsCall__Inputs(this);
  }

  get outputs(): RobustSwapERC20ForAnyNFTsCall__Outputs {
    return new RobustSwapERC20ForAnyNFTsCall__Outputs(this);
  }
}

export class RobustSwapERC20ForAnyNFTsCall__Inputs {
  _call: RobustSwapERC20ForAnyNFTsCall;

  constructor(call: RobustSwapERC20ForAnyNFTsCall) {
    this._call = call;
  }

  get swapList(): Array<RobustSwapERC20ForAnyNFTsCallSwapListStruct> {
    return this._call.inputValues[0].value.toTupleArray<
      RobustSwapERC20ForAnyNFTsCallSwapListStruct
    >();
  }

  get inputAmount(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }

  get nftRecipient(): Address {
    return this._call.inputValues[2].value.toAddress();
  }

  get deadline(): BigInt {
    return this._call.inputValues[3].value.toBigInt();
  }
}

export class RobustSwapERC20ForAnyNFTsCall__Outputs {
  _call: RobustSwapERC20ForAnyNFTsCall;

  constructor(call: RobustSwapERC20ForAnyNFTsCall) {
    this._call = call;
  }

  get remainingValue(): BigInt {
    return this._call.outputValues[0].value.toBigInt();
  }
}

export class RobustSwapERC20ForAnyNFTsCallSwapListStruct extends ethereum.Tuple {
  get swapInfo(): RobustSwapERC20ForAnyNFTsCallSwapListSwapInfoStruct {
    return changetype<RobustSwapERC20ForAnyNFTsCallSwapListSwapInfoStruct>(
      this[0].toTuple()
    );
  }

  get maxCost(): BigInt {
    return this[1].toBigInt();
  }
}

export class RobustSwapERC20ForAnyNFTsCallSwapListSwapInfoStruct extends ethereum.Tuple {
  get pair(): Address {
    return this[0].toAddress();
  }

  get numItems(): BigInt {
    return this[1].toBigInt();
  }
}

export class RobustSwapERC20ForSpecificNFTsCall extends ethereum.Call {
  get inputs(): RobustSwapERC20ForSpecificNFTsCall__Inputs {
    return new RobustSwapERC20ForSpecificNFTsCall__Inputs(this);
  }

  get outputs(): RobustSwapERC20ForSpecificNFTsCall__Outputs {
    return new RobustSwapERC20ForSpecificNFTsCall__Outputs(this);
  }
}

export class RobustSwapERC20ForSpecificNFTsCall__Inputs {
  _call: RobustSwapERC20ForSpecificNFTsCall;

  constructor(call: RobustSwapERC20ForSpecificNFTsCall) {
    this._call = call;
  }

  get swapList(): Array<RobustSwapERC20ForSpecificNFTsCallSwapListStruct> {
    return this._call.inputValues[0].value.toTupleArray<
      RobustSwapERC20ForSpecificNFTsCallSwapListStruct
    >();
  }

  get inputAmount(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }

  get nftRecipient(): Address {
    return this._call.inputValues[2].value.toAddress();
  }

  get deadline(): BigInt {
    return this._call.inputValues[3].value.toBigInt();
  }
}

export class RobustSwapERC20ForSpecificNFTsCall__Outputs {
  _call: RobustSwapERC20ForSpecificNFTsCall;

  constructor(call: RobustSwapERC20ForSpecificNFTsCall) {
    this._call = call;
  }

  get remainingValue(): BigInt {
    return this._call.outputValues[0].value.toBigInt();
  }
}

export class RobustSwapERC20ForSpecificNFTsCallSwapListStruct extends ethereum.Tuple {
  get swapInfo(): RobustSwapERC20ForSpecificNFTsCallSwapListSwapInfoStruct {
    return changetype<RobustSwapERC20ForSpecificNFTsCallSwapListSwapInfoStruct>(
      this[0].toTuple()
    );
  }

  get maxCost(): BigInt {
    return this[1].toBigInt();
  }
}

export class RobustSwapERC20ForSpecificNFTsCallSwapListSwapInfoStruct extends ethereum.Tuple {
  get pair(): Address {
    return this[0].toAddress();
  }

  get nftIds(): Array<BigInt> {
    return this[1].toBigIntArray();
  }
}

export class RobustSwapERC20ForSpecificNFTsAndNFTsToTokenCall extends ethereum.Call {
  get inputs(): RobustSwapERC20ForSpecificNFTsAndNFTsToTokenCall__Inputs {
    return new RobustSwapERC20ForSpecificNFTsAndNFTsToTokenCall__Inputs(this);
  }

  get outputs(): RobustSwapERC20ForSpecificNFTsAndNFTsToTokenCall__Outputs {
    return new RobustSwapERC20ForSpecificNFTsAndNFTsToTokenCall__Outputs(this);
  }
}

export class RobustSwapERC20ForSpecificNFTsAndNFTsToTokenCall__Inputs {
  _call: RobustSwapERC20ForSpecificNFTsAndNFTsToTokenCall;

  constructor(call: RobustSwapERC20ForSpecificNFTsAndNFTsToTokenCall) {
    this._call = call;
  }

  get params(): RobustSwapERC20ForSpecificNFTsAndNFTsToTokenCallParamsStruct {
    return changetype<
      RobustSwapERC20ForSpecificNFTsAndNFTsToTokenCallParamsStruct
    >(this._call.inputValues[0].value.toTuple());
  }
}

export class RobustSwapERC20ForSpecificNFTsAndNFTsToTokenCall__Outputs {
  _call: RobustSwapERC20ForSpecificNFTsAndNFTsToTokenCall;

  constructor(call: RobustSwapERC20ForSpecificNFTsAndNFTsToTokenCall) {
    this._call = call;
  }

  get remainingValue(): BigInt {
    return this._call.outputValues[0].value.toBigInt();
  }

  get outputAmount(): BigInt {
    return this._call.outputValues[1].value.toBigInt();
  }
}

export class RobustSwapERC20ForSpecificNFTsAndNFTsToTokenCallParamsStruct extends ethereum.Tuple {
  get tokenToNFTTrades(): Array<
    RobustSwapERC20ForSpecificNFTsAndNFTsToTokenCallParamsTokenToNFTTradesStruct
  > {
    return this[0].toTupleArray<
      RobustSwapERC20ForSpecificNFTsAndNFTsToTokenCallParamsTokenToNFTTradesStruct
    >();
  }

  get nftToTokenTrades(): Array<
    RobustSwapERC20ForSpecificNFTsAndNFTsToTokenCallParamsNftToTokenTradesStruct
  > {
    return this[1].toTupleArray<
      RobustSwapERC20ForSpecificNFTsAndNFTsToTokenCallParamsNftToTokenTradesStruct
    >();
  }

  get inputAmount(): BigInt {
    return this[2].toBigInt();
  }

  get tokenRecipient(): Address {
    return this[3].toAddress();
  }

  get nftRecipient(): Address {
    return this[4].toAddress();
  }
}

export class RobustSwapERC20ForSpecificNFTsAndNFTsToTokenCallParamsTokenToNFTTradesStruct extends ethereum.Tuple {
  get swapInfo(): RobustSwapERC20ForSpecificNFTsAndNFTsToTokenCallParamsTokenToNFTTradesSwapInfoStruct {
    return changetype<
      RobustSwapERC20ForSpecificNFTsAndNFTsToTokenCallParamsTokenToNFTTradesSwapInfoStruct
    >(this[0].toTuple());
  }

  get maxCost(): BigInt {
    return this[1].toBigInt();
  }
}

export class RobustSwapERC20ForSpecificNFTsAndNFTsToTokenCallParamsTokenToNFTTradesSwapInfoStruct extends ethereum.Tuple {
  get pair(): Address {
    return this[0].toAddress();
  }

  get nftIds(): Array<BigInt> {
    return this[1].toBigIntArray();
  }
}

export class RobustSwapERC20ForSpecificNFTsAndNFTsToTokenCallParamsNftToTokenTradesStruct extends ethereum.Tuple {
  get swapInfo(): RobustSwapERC20ForSpecificNFTsAndNFTsToTokenCallParamsNftToTokenTradesSwapInfoStruct {
    return changetype<
      RobustSwapERC20ForSpecificNFTsAndNFTsToTokenCallParamsNftToTokenTradesSwapInfoStruct
    >(this[0].toTuple());
  }

  get minOutput(): BigInt {
    return this[1].toBigInt();
  }
}

export class RobustSwapERC20ForSpecificNFTsAndNFTsToTokenCallParamsNftToTokenTradesSwapInfoStruct extends ethereum.Tuple {
  get pair(): Address {
    return this[0].toAddress();
  }

  get nftIds(): Array<BigInt> {
    return this[1].toBigIntArray();
  }
}

export class RobustSwapETHForAnyNFTsCall extends ethereum.Call {
  get inputs(): RobustSwapETHForAnyNFTsCall__Inputs {
    return new RobustSwapETHForAnyNFTsCall__Inputs(this);
  }

  get outputs(): RobustSwapETHForAnyNFTsCall__Outputs {
    return new RobustSwapETHForAnyNFTsCall__Outputs(this);
  }
}

export class RobustSwapETHForAnyNFTsCall__Inputs {
  _call: RobustSwapETHForAnyNFTsCall;

  constructor(call: RobustSwapETHForAnyNFTsCall) {
    this._call = call;
  }

  get swapList(): Array<RobustSwapETHForAnyNFTsCallSwapListStruct> {
    return this._call.inputValues[0].value.toTupleArray<
      RobustSwapETHForAnyNFTsCallSwapListStruct
    >();
  }

  get ethRecipient(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get nftRecipient(): Address {
    return this._call.inputValues[2].value.toAddress();
  }

  get deadline(): BigInt {
    return this._call.inputValues[3].value.toBigInt();
  }
}

export class RobustSwapETHForAnyNFTsCall__Outputs {
  _call: RobustSwapETHForAnyNFTsCall;

  constructor(call: RobustSwapETHForAnyNFTsCall) {
    this._call = call;
  }

  get remainingValue(): BigInt {
    return this._call.outputValues[0].value.toBigInt();
  }
}

export class RobustSwapETHForAnyNFTsCallSwapListStruct extends ethereum.Tuple {
  get swapInfo(): RobustSwapETHForAnyNFTsCallSwapListSwapInfoStruct {
    return changetype<RobustSwapETHForAnyNFTsCallSwapListSwapInfoStruct>(
      this[0].toTuple()
    );
  }

  get maxCost(): BigInt {
    return this[1].toBigInt();
  }
}

export class RobustSwapETHForAnyNFTsCallSwapListSwapInfoStruct extends ethereum.Tuple {
  get pair(): Address {
    return this[0].toAddress();
  }

  get numItems(): BigInt {
    return this[1].toBigInt();
  }
}

export class RobustSwapETHForSpecificNFTsCall extends ethereum.Call {
  get inputs(): RobustSwapETHForSpecificNFTsCall__Inputs {
    return new RobustSwapETHForSpecificNFTsCall__Inputs(this);
  }

  get outputs(): RobustSwapETHForSpecificNFTsCall__Outputs {
    return new RobustSwapETHForSpecificNFTsCall__Outputs(this);
  }
}

export class RobustSwapETHForSpecificNFTsCall__Inputs {
  _call: RobustSwapETHForSpecificNFTsCall;

  constructor(call: RobustSwapETHForSpecificNFTsCall) {
    this._call = call;
  }

  get swapList(): Array<RobustSwapETHForSpecificNFTsCallSwapListStruct> {
    return this._call.inputValues[0].value.toTupleArray<
      RobustSwapETHForSpecificNFTsCallSwapListStruct
    >();
  }

  get ethRecipient(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get nftRecipient(): Address {
    return this._call.inputValues[2].value.toAddress();
  }

  get deadline(): BigInt {
    return this._call.inputValues[3].value.toBigInt();
  }
}

export class RobustSwapETHForSpecificNFTsCall__Outputs {
  _call: RobustSwapETHForSpecificNFTsCall;

  constructor(call: RobustSwapETHForSpecificNFTsCall) {
    this._call = call;
  }

  get remainingValue(): BigInt {
    return this._call.outputValues[0].value.toBigInt();
  }
}

export class RobustSwapETHForSpecificNFTsCallSwapListStruct extends ethereum.Tuple {
  get swapInfo(): RobustSwapETHForSpecificNFTsCallSwapListSwapInfoStruct {
    return changetype<RobustSwapETHForSpecificNFTsCallSwapListSwapInfoStruct>(
      this[0].toTuple()
    );
  }

  get maxCost(): BigInt {
    return this[1].toBigInt();
  }
}

export class RobustSwapETHForSpecificNFTsCallSwapListSwapInfoStruct extends ethereum.Tuple {
  get pair(): Address {
    return this[0].toAddress();
  }

  get nftIds(): Array<BigInt> {
    return this[1].toBigIntArray();
  }
}

export class RobustSwapETHForSpecificNFTsAndNFTsToTokenCall extends ethereum.Call {
  get inputs(): RobustSwapETHForSpecificNFTsAndNFTsToTokenCall__Inputs {
    return new RobustSwapETHForSpecificNFTsAndNFTsToTokenCall__Inputs(this);
  }

  get outputs(): RobustSwapETHForSpecificNFTsAndNFTsToTokenCall__Outputs {
    return new RobustSwapETHForSpecificNFTsAndNFTsToTokenCall__Outputs(this);
  }
}

export class RobustSwapETHForSpecificNFTsAndNFTsToTokenCall__Inputs {
  _call: RobustSwapETHForSpecificNFTsAndNFTsToTokenCall;

  constructor(call: RobustSwapETHForSpecificNFTsAndNFTsToTokenCall) {
    this._call = call;
  }

  get params(): RobustSwapETHForSpecificNFTsAndNFTsToTokenCallParamsStruct {
    return changetype<
      RobustSwapETHForSpecificNFTsAndNFTsToTokenCallParamsStruct
    >(this._call.inputValues[0].value.toTuple());
  }
}

export class RobustSwapETHForSpecificNFTsAndNFTsToTokenCall__Outputs {
  _call: RobustSwapETHForSpecificNFTsAndNFTsToTokenCall;

  constructor(call: RobustSwapETHForSpecificNFTsAndNFTsToTokenCall) {
    this._call = call;
  }

  get remainingValue(): BigInt {
    return this._call.outputValues[0].value.toBigInt();
  }

  get outputAmount(): BigInt {
    return this._call.outputValues[1].value.toBigInt();
  }
}

export class RobustSwapETHForSpecificNFTsAndNFTsToTokenCallParamsStruct extends ethereum.Tuple {
  get tokenToNFTTrades(): Array<
    RobustSwapETHForSpecificNFTsAndNFTsToTokenCallParamsTokenToNFTTradesStruct
  > {
    return this[0].toTupleArray<
      RobustSwapETHForSpecificNFTsAndNFTsToTokenCallParamsTokenToNFTTradesStruct
    >();
  }

  get nftToTokenTrades(): Array<
    RobustSwapETHForSpecificNFTsAndNFTsToTokenCallParamsNftToTokenTradesStruct
  > {
    return this[1].toTupleArray<
      RobustSwapETHForSpecificNFTsAndNFTsToTokenCallParamsNftToTokenTradesStruct
    >();
  }

  get inputAmount(): BigInt {
    return this[2].toBigInt();
  }

  get tokenRecipient(): Address {
    return this[3].toAddress();
  }

  get nftRecipient(): Address {
    return this[4].toAddress();
  }
}

export class RobustSwapETHForSpecificNFTsAndNFTsToTokenCallParamsTokenToNFTTradesStruct extends ethereum.Tuple {
  get swapInfo(): RobustSwapETHForSpecificNFTsAndNFTsToTokenCallParamsTokenToNFTTradesSwapInfoStruct {
    return changetype<
      RobustSwapETHForSpecificNFTsAndNFTsToTokenCallParamsTokenToNFTTradesSwapInfoStruct
    >(this[0].toTuple());
  }

  get maxCost(): BigInt {
    return this[1].toBigInt();
  }
}

export class RobustSwapETHForSpecificNFTsAndNFTsToTokenCallParamsTokenToNFTTradesSwapInfoStruct extends ethereum.Tuple {
  get pair(): Address {
    return this[0].toAddress();
  }

  get nftIds(): Array<BigInt> {
    return this[1].toBigIntArray();
  }
}

export class RobustSwapETHForSpecificNFTsAndNFTsToTokenCallParamsNftToTokenTradesStruct extends ethereum.Tuple {
  get swapInfo(): RobustSwapETHForSpecificNFTsAndNFTsToTokenCallParamsNftToTokenTradesSwapInfoStruct {
    return changetype<
      RobustSwapETHForSpecificNFTsAndNFTsToTokenCallParamsNftToTokenTradesSwapInfoStruct
    >(this[0].toTuple());
  }

  get minOutput(): BigInt {
    return this[1].toBigInt();
  }
}

export class RobustSwapETHForSpecificNFTsAndNFTsToTokenCallParamsNftToTokenTradesSwapInfoStruct extends ethereum.Tuple {
  get pair(): Address {
    return this[0].toAddress();
  }

  get nftIds(): Array<BigInt> {
    return this[1].toBigIntArray();
  }
}

export class RobustSwapNFTsForTokenCall extends ethereum.Call {
  get inputs(): RobustSwapNFTsForTokenCall__Inputs {
    return new RobustSwapNFTsForTokenCall__Inputs(this);
  }

  get outputs(): RobustSwapNFTsForTokenCall__Outputs {
    return new RobustSwapNFTsForTokenCall__Outputs(this);
  }
}

export class RobustSwapNFTsForTokenCall__Inputs {
  _call: RobustSwapNFTsForTokenCall;

  constructor(call: RobustSwapNFTsForTokenCall) {
    this._call = call;
  }

  get swapList(): Array<RobustSwapNFTsForTokenCallSwapListStruct> {
    return this._call.inputValues[0].value.toTupleArray<
      RobustSwapNFTsForTokenCallSwapListStruct
    >();
  }

  get tokenRecipient(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get deadline(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }
}

export class RobustSwapNFTsForTokenCall__Outputs {
  _call: RobustSwapNFTsForTokenCall;

  constructor(call: RobustSwapNFTsForTokenCall) {
    this._call = call;
  }

  get outputAmount(): BigInt {
    return this._call.outputValues[0].value.toBigInt();
  }
}

export class RobustSwapNFTsForTokenCallSwapListStruct extends ethereum.Tuple {
  get swapInfo(): RobustSwapNFTsForTokenCallSwapListSwapInfoStruct {
    return changetype<RobustSwapNFTsForTokenCallSwapListSwapInfoStruct>(
      this[0].toTuple()
    );
  }

  get minOutput(): BigInt {
    return this[1].toBigInt();
  }
}

export class RobustSwapNFTsForTokenCallSwapListSwapInfoStruct extends ethereum.Tuple {
  get pair(): Address {
    return this[0].toAddress();
  }

  get nftIds(): Array<BigInt> {
    return this[1].toBigIntArray();
  }
}

export class SwapERC20ForAnyNFTsCall extends ethereum.Call {
  get inputs(): SwapERC20ForAnyNFTsCall__Inputs {
    return new SwapERC20ForAnyNFTsCall__Inputs(this);
  }

  get outputs(): SwapERC20ForAnyNFTsCall__Outputs {
    return new SwapERC20ForAnyNFTsCall__Outputs(this);
  }
}

export class SwapERC20ForAnyNFTsCall__Inputs {
  _call: SwapERC20ForAnyNFTsCall;

  constructor(call: SwapERC20ForAnyNFTsCall) {
    this._call = call;
  }

  get swapList(): Array<SwapERC20ForAnyNFTsCallSwapListStruct> {
    return this._call.inputValues[0].value.toTupleArray<
      SwapERC20ForAnyNFTsCallSwapListStruct
    >();
  }

  get inputAmount(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }

  get nftRecipient(): Address {
    return this._call.inputValues[2].value.toAddress();
  }

  get deadline(): BigInt {
    return this._call.inputValues[3].value.toBigInt();
  }
}

export class SwapERC20ForAnyNFTsCall__Outputs {
  _call: SwapERC20ForAnyNFTsCall;

  constructor(call: SwapERC20ForAnyNFTsCall) {
    this._call = call;
  }

  get remainingValue(): BigInt {
    return this._call.outputValues[0].value.toBigInt();
  }
}

export class SwapERC20ForAnyNFTsCallSwapListStruct extends ethereum.Tuple {
  get pair(): Address {
    return this[0].toAddress();
  }

  get numItems(): BigInt {
    return this[1].toBigInt();
  }
}

export class SwapERC20ForSpecificNFTsCall extends ethereum.Call {
  get inputs(): SwapERC20ForSpecificNFTsCall__Inputs {
    return new SwapERC20ForSpecificNFTsCall__Inputs(this);
  }

  get outputs(): SwapERC20ForSpecificNFTsCall__Outputs {
    return new SwapERC20ForSpecificNFTsCall__Outputs(this);
  }
}

export class SwapERC20ForSpecificNFTsCall__Inputs {
  _call: SwapERC20ForSpecificNFTsCall;

  constructor(call: SwapERC20ForSpecificNFTsCall) {
    this._call = call;
  }

  get swapList(): Array<SwapERC20ForSpecificNFTsCallSwapListStruct> {
    return this._call.inputValues[0].value.toTupleArray<
      SwapERC20ForSpecificNFTsCallSwapListStruct
    >();
  }

  get inputAmount(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }

  get nftRecipient(): Address {
    return this._call.inputValues[2].value.toAddress();
  }

  get deadline(): BigInt {
    return this._call.inputValues[3].value.toBigInt();
  }
}

export class SwapERC20ForSpecificNFTsCall__Outputs {
  _call: SwapERC20ForSpecificNFTsCall;

  constructor(call: SwapERC20ForSpecificNFTsCall) {
    this._call = call;
  }

  get remainingValue(): BigInt {
    return this._call.outputValues[0].value.toBigInt();
  }
}

export class SwapERC20ForSpecificNFTsCallSwapListStruct extends ethereum.Tuple {
  get pair(): Address {
    return this[0].toAddress();
  }

  get nftIds(): Array<BigInt> {
    return this[1].toBigIntArray();
  }
}

export class SwapETHForAnyNFTsCall extends ethereum.Call {
  get inputs(): SwapETHForAnyNFTsCall__Inputs {
    return new SwapETHForAnyNFTsCall__Inputs(this);
  }

  get outputs(): SwapETHForAnyNFTsCall__Outputs {
    return new SwapETHForAnyNFTsCall__Outputs(this);
  }
}

export class SwapETHForAnyNFTsCall__Inputs {
  _call: SwapETHForAnyNFTsCall;

  constructor(call: SwapETHForAnyNFTsCall) {
    this._call = call;
  }

  get swapList(): Array<SwapETHForAnyNFTsCallSwapListStruct> {
    return this._call.inputValues[0].value.toTupleArray<
      SwapETHForAnyNFTsCallSwapListStruct
    >();
  }

  get ethRecipient(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get nftRecipient(): Address {
    return this._call.inputValues[2].value.toAddress();
  }

  get deadline(): BigInt {
    return this._call.inputValues[3].value.toBigInt();
  }
}

export class SwapETHForAnyNFTsCall__Outputs {
  _call: SwapETHForAnyNFTsCall;

  constructor(call: SwapETHForAnyNFTsCall) {
    this._call = call;
  }

  get remainingValue(): BigInt {
    return this._call.outputValues[0].value.toBigInt();
  }
}

export class SwapETHForAnyNFTsCallSwapListStruct extends ethereum.Tuple {
  get pair(): Address {
    return this[0].toAddress();
  }

  get numItems(): BigInt {
    return this[1].toBigInt();
  }
}

export class SwapETHForSpecificNFTsCall extends ethereum.Call {
  get inputs(): SwapETHForSpecificNFTsCall__Inputs {
    return new SwapETHForSpecificNFTsCall__Inputs(this);
  }

  get outputs(): SwapETHForSpecificNFTsCall__Outputs {
    return new SwapETHForSpecificNFTsCall__Outputs(this);
  }
}

export class SwapETHForSpecificNFTsCall__Inputs {
  _call: SwapETHForSpecificNFTsCall;

  constructor(call: SwapETHForSpecificNFTsCall) {
    this._call = call;
  }

  get swapList(): Array<SwapETHForSpecificNFTsCallSwapListStruct> {
    return this._call.inputValues[0].value.toTupleArray<
      SwapETHForSpecificNFTsCallSwapListStruct
    >();
  }

  get ethRecipient(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get nftRecipient(): Address {
    return this._call.inputValues[2].value.toAddress();
  }

  get deadline(): BigInt {
    return this._call.inputValues[3].value.toBigInt();
  }
}

export class SwapETHForSpecificNFTsCall__Outputs {
  _call: SwapETHForSpecificNFTsCall;

  constructor(call: SwapETHForSpecificNFTsCall) {
    this._call = call;
  }

  get remainingValue(): BigInt {
    return this._call.outputValues[0].value.toBigInt();
  }
}

export class SwapETHForSpecificNFTsCallSwapListStruct extends ethereum.Tuple {
  get pair(): Address {
    return this[0].toAddress();
  }

  get nftIds(): Array<BigInt> {
    return this[1].toBigIntArray();
  }
}

export class SwapNFTsForAnyNFTsThroughERC20Call extends ethereum.Call {
  get inputs(): SwapNFTsForAnyNFTsThroughERC20Call__Inputs {
    return new SwapNFTsForAnyNFTsThroughERC20Call__Inputs(this);
  }

  get outputs(): SwapNFTsForAnyNFTsThroughERC20Call__Outputs {
    return new SwapNFTsForAnyNFTsThroughERC20Call__Outputs(this);
  }
}

export class SwapNFTsForAnyNFTsThroughERC20Call__Inputs {
  _call: SwapNFTsForAnyNFTsThroughERC20Call;

  constructor(call: SwapNFTsForAnyNFTsThroughERC20Call) {
    this._call = call;
  }

  get trade(): SwapNFTsForAnyNFTsThroughERC20CallTradeStruct {
    return changetype<SwapNFTsForAnyNFTsThroughERC20CallTradeStruct>(
      this._call.inputValues[0].value.toTuple()
    );
  }

  get inputAmount(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }

  get minOutput(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }

  get nftRecipient(): Address {
    return this._call.inputValues[3].value.toAddress();
  }

  get deadline(): BigInt {
    return this._call.inputValues[4].value.toBigInt();
  }
}

export class SwapNFTsForAnyNFTsThroughERC20Call__Outputs {
  _call: SwapNFTsForAnyNFTsThroughERC20Call;

  constructor(call: SwapNFTsForAnyNFTsThroughERC20Call) {
    this._call = call;
  }

  get outputAmount(): BigInt {
    return this._call.outputValues[0].value.toBigInt();
  }
}

export class SwapNFTsForAnyNFTsThroughERC20CallTradeStruct extends ethereum.Tuple {
  get nftToTokenTrades(): Array<
    SwapNFTsForAnyNFTsThroughERC20CallTradeNftToTokenTradesStruct
  > {
    return this[0].toTupleArray<
      SwapNFTsForAnyNFTsThroughERC20CallTradeNftToTokenTradesStruct
    >();
  }

  get tokenToNFTTrades(): Array<
    SwapNFTsForAnyNFTsThroughERC20CallTradeTokenToNFTTradesStruct
  > {
    return this[1].toTupleArray<
      SwapNFTsForAnyNFTsThroughERC20CallTradeTokenToNFTTradesStruct
    >();
  }
}

export class SwapNFTsForAnyNFTsThroughERC20CallTradeNftToTokenTradesStruct extends ethereum.Tuple {
  get pair(): Address {
    return this[0].toAddress();
  }

  get nftIds(): Array<BigInt> {
    return this[1].toBigIntArray();
  }
}

export class SwapNFTsForAnyNFTsThroughERC20CallTradeTokenToNFTTradesStruct extends ethereum.Tuple {
  get pair(): Address {
    return this[0].toAddress();
  }

  get numItems(): BigInt {
    return this[1].toBigInt();
  }
}

export class SwapNFTsForAnyNFTsThroughETHCall extends ethereum.Call {
  get inputs(): SwapNFTsForAnyNFTsThroughETHCall__Inputs {
    return new SwapNFTsForAnyNFTsThroughETHCall__Inputs(this);
  }

  get outputs(): SwapNFTsForAnyNFTsThroughETHCall__Outputs {
    return new SwapNFTsForAnyNFTsThroughETHCall__Outputs(this);
  }
}

export class SwapNFTsForAnyNFTsThroughETHCall__Inputs {
  _call: SwapNFTsForAnyNFTsThroughETHCall;

  constructor(call: SwapNFTsForAnyNFTsThroughETHCall) {
    this._call = call;
  }

  get trade(): SwapNFTsForAnyNFTsThroughETHCallTradeStruct {
    return changetype<SwapNFTsForAnyNFTsThroughETHCallTradeStruct>(
      this._call.inputValues[0].value.toTuple()
    );
  }

  get minOutput(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }

  get ethRecipient(): Address {
    return this._call.inputValues[2].value.toAddress();
  }

  get nftRecipient(): Address {
    return this._call.inputValues[3].value.toAddress();
  }

  get deadline(): BigInt {
    return this._call.inputValues[4].value.toBigInt();
  }
}

export class SwapNFTsForAnyNFTsThroughETHCall__Outputs {
  _call: SwapNFTsForAnyNFTsThroughETHCall;

  constructor(call: SwapNFTsForAnyNFTsThroughETHCall) {
    this._call = call;
  }

  get outputAmount(): BigInt {
    return this._call.outputValues[0].value.toBigInt();
  }
}

export class SwapNFTsForAnyNFTsThroughETHCallTradeStruct extends ethereum.Tuple {
  get nftToTokenTrades(): Array<
    SwapNFTsForAnyNFTsThroughETHCallTradeNftToTokenTradesStruct
  > {
    return this[0].toTupleArray<
      SwapNFTsForAnyNFTsThroughETHCallTradeNftToTokenTradesStruct
    >();
  }

  get tokenToNFTTrades(): Array<
    SwapNFTsForAnyNFTsThroughETHCallTradeTokenToNFTTradesStruct
  > {
    return this[1].toTupleArray<
      SwapNFTsForAnyNFTsThroughETHCallTradeTokenToNFTTradesStruct
    >();
  }
}

export class SwapNFTsForAnyNFTsThroughETHCallTradeNftToTokenTradesStruct extends ethereum.Tuple {
  get pair(): Address {
    return this[0].toAddress();
  }

  get nftIds(): Array<BigInt> {
    return this[1].toBigIntArray();
  }
}

export class SwapNFTsForAnyNFTsThroughETHCallTradeTokenToNFTTradesStruct extends ethereum.Tuple {
  get pair(): Address {
    return this[0].toAddress();
  }

  get numItems(): BigInt {
    return this[1].toBigInt();
  }
}

export class SwapNFTsForSpecificNFTsThroughERC20Call extends ethereum.Call {
  get inputs(): SwapNFTsForSpecificNFTsThroughERC20Call__Inputs {
    return new SwapNFTsForSpecificNFTsThroughERC20Call__Inputs(this);
  }

  get outputs(): SwapNFTsForSpecificNFTsThroughERC20Call__Outputs {
    return new SwapNFTsForSpecificNFTsThroughERC20Call__Outputs(this);
  }
}

export class SwapNFTsForSpecificNFTsThroughERC20Call__Inputs {
  _call: SwapNFTsForSpecificNFTsThroughERC20Call;

  constructor(call: SwapNFTsForSpecificNFTsThroughERC20Call) {
    this._call = call;
  }

  get trade(): SwapNFTsForSpecificNFTsThroughERC20CallTradeStruct {
    return changetype<SwapNFTsForSpecificNFTsThroughERC20CallTradeStruct>(
      this._call.inputValues[0].value.toTuple()
    );
  }

  get inputAmount(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }

  get minOutput(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }

  get nftRecipient(): Address {
    return this._call.inputValues[3].value.toAddress();
  }

  get deadline(): BigInt {
    return this._call.inputValues[4].value.toBigInt();
  }
}

export class SwapNFTsForSpecificNFTsThroughERC20Call__Outputs {
  _call: SwapNFTsForSpecificNFTsThroughERC20Call;

  constructor(call: SwapNFTsForSpecificNFTsThroughERC20Call) {
    this._call = call;
  }

  get outputAmount(): BigInt {
    return this._call.outputValues[0].value.toBigInt();
  }
}

export class SwapNFTsForSpecificNFTsThroughERC20CallTradeStruct extends ethereum.Tuple {
  get nftToTokenTrades(): Array<
    SwapNFTsForSpecificNFTsThroughERC20CallTradeNftToTokenTradesStruct
  > {
    return this[0].toTupleArray<
      SwapNFTsForSpecificNFTsThroughERC20CallTradeNftToTokenTradesStruct
    >();
  }

  get tokenToNFTTrades(): Array<
    SwapNFTsForSpecificNFTsThroughERC20CallTradeTokenToNFTTradesStruct
  > {
    return this[1].toTupleArray<
      SwapNFTsForSpecificNFTsThroughERC20CallTradeTokenToNFTTradesStruct
    >();
  }
}

export class SwapNFTsForSpecificNFTsThroughERC20CallTradeNftToTokenTradesStruct extends ethereum.Tuple {
  get pair(): Address {
    return this[0].toAddress();
  }

  get nftIds(): Array<BigInt> {
    return this[1].toBigIntArray();
  }
}

export class SwapNFTsForSpecificNFTsThroughERC20CallTradeTokenToNFTTradesStruct extends ethereum.Tuple {
  get pair(): Address {
    return this[0].toAddress();
  }

  get nftIds(): Array<BigInt> {
    return this[1].toBigIntArray();
  }
}

export class SwapNFTsForSpecificNFTsThroughETHCall extends ethereum.Call {
  get inputs(): SwapNFTsForSpecificNFTsThroughETHCall__Inputs {
    return new SwapNFTsForSpecificNFTsThroughETHCall__Inputs(this);
  }

  get outputs(): SwapNFTsForSpecificNFTsThroughETHCall__Outputs {
    return new SwapNFTsForSpecificNFTsThroughETHCall__Outputs(this);
  }
}

export class SwapNFTsForSpecificNFTsThroughETHCall__Inputs {
  _call: SwapNFTsForSpecificNFTsThroughETHCall;

  constructor(call: SwapNFTsForSpecificNFTsThroughETHCall) {
    this._call = call;
  }

  get trade(): SwapNFTsForSpecificNFTsThroughETHCallTradeStruct {
    return changetype<SwapNFTsForSpecificNFTsThroughETHCallTradeStruct>(
      this._call.inputValues[0].value.toTuple()
    );
  }

  get minOutput(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }

  get ethRecipient(): Address {
    return this._call.inputValues[2].value.toAddress();
  }

  get nftRecipient(): Address {
    return this._call.inputValues[3].value.toAddress();
  }

  get deadline(): BigInt {
    return this._call.inputValues[4].value.toBigInt();
  }
}

export class SwapNFTsForSpecificNFTsThroughETHCall__Outputs {
  _call: SwapNFTsForSpecificNFTsThroughETHCall;

  constructor(call: SwapNFTsForSpecificNFTsThroughETHCall) {
    this._call = call;
  }

  get outputAmount(): BigInt {
    return this._call.outputValues[0].value.toBigInt();
  }
}

export class SwapNFTsForSpecificNFTsThroughETHCallTradeStruct extends ethereum.Tuple {
  get nftToTokenTrades(): Array<
    SwapNFTsForSpecificNFTsThroughETHCallTradeNftToTokenTradesStruct
  > {
    return this[0].toTupleArray<
      SwapNFTsForSpecificNFTsThroughETHCallTradeNftToTokenTradesStruct
    >();
  }

  get tokenToNFTTrades(): Array<
    SwapNFTsForSpecificNFTsThroughETHCallTradeTokenToNFTTradesStruct
  > {
    return this[1].toTupleArray<
      SwapNFTsForSpecificNFTsThroughETHCallTradeTokenToNFTTradesStruct
    >();
  }
}

export class SwapNFTsForSpecificNFTsThroughETHCallTradeNftToTokenTradesStruct extends ethereum.Tuple {
  get pair(): Address {
    return this[0].toAddress();
  }

  get nftIds(): Array<BigInt> {
    return this[1].toBigIntArray();
  }
}

export class SwapNFTsForSpecificNFTsThroughETHCallTradeTokenToNFTTradesStruct extends ethereum.Tuple {
  get pair(): Address {
    return this[0].toAddress();
  }

  get nftIds(): Array<BigInt> {
    return this[1].toBigIntArray();
  }
}

export class SwapNFTsForTokenCall extends ethereum.Call {
  get inputs(): SwapNFTsForTokenCall__Inputs {
    return new SwapNFTsForTokenCall__Inputs(this);
  }

  get outputs(): SwapNFTsForTokenCall__Outputs {
    return new SwapNFTsForTokenCall__Outputs(this);
  }
}

export class SwapNFTsForTokenCall__Inputs {
  _call: SwapNFTsForTokenCall;

  constructor(call: SwapNFTsForTokenCall) {
    this._call = call;
  }

  get swapList(): Array<SwapNFTsForTokenCallSwapListStruct> {
    return this._call.inputValues[0].value.toTupleArray<
      SwapNFTsForTokenCallSwapListStruct
    >();
  }

  get minOutput(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }

  get tokenRecipient(): Address {
    return this._call.inputValues[2].value.toAddress();
  }

  get deadline(): BigInt {
    return this._call.inputValues[3].value.toBigInt();
  }
}

export class SwapNFTsForTokenCall__Outputs {
  _call: SwapNFTsForTokenCall;

  constructor(call: SwapNFTsForTokenCall) {
    this._call = call;
  }

  get outputAmount(): BigInt {
    return this._call.outputValues[0].value.toBigInt();
  }
}

export class SwapNFTsForTokenCallSwapListStruct extends ethereum.Tuple {
  get pair(): Address {
    return this[0].toAddress();
  }

  get nftIds(): Array<BigInt> {
    return this[1].toBigIntArray();
  }
}
